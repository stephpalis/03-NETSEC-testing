#! /usr/bin/env python3
##################################################
############ CLIENT FOR TESTING PURPOSES
##################################################
import sys, yaml, socket, struct, binascii
import nstp_v4_pb2 as nstp_proto
import nacl.bindings as bindings

client_cert_file = open("/data/client.crt", "rb").read()
client_cert      = nstp_proto.Certificate()
client_cert.ParseFromString(client_cert_file)

client_private_key_file = open("/data/client.key", "rb").read()
client_private_key      = nstp_proto.PrivateKey()
client_private_key.ParseFromString(client_private_key_file)

ca_private_key_file = open("/data/ca.key", "rb").read()
ca_private_key      = nstp_proto.PrivateKey()
ca_private_key.ParseFromString(ca_private_key_file)

# Set up the server socket
server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_sock.connect(("172.17.0.1", 22300))
# Set up the status socket
status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
status_sock.connect(("127.0.0.1", 22301))


def main():
  #printCertStores()

  #testInvalid1()
  #testInvalid2()
  #testInvalid4()
<<<<<<< HEAD
  #testInvalid5()
  #testInvalid7()

  # After each test, receive the result
  print('Receiving a new NSTPMessage')
  nstp_msg = nstp_proto.NSTPMessage()
  msg_length_recv = recvSafe(server_sock, 2)
  msg_length = int(binascii.hexlify(msg_length_recv), 16)
  print('msg_length=' + str(msg_length))
  data = recvSafe(server_sock, msg_length)
  nstp_msg.ParseFromString(data)
  print('Received NSTPMessage:')
  print(nstp_msg)
=======
  testInvalid5()
  testInvalid6()
>>>>>>> e6b1548ea2cf9c1ef3ad90b3d36b4e8d1c43ff85

##################################################
############ Test invalid client certs
##################################################
'''
1) More than one subject            -- DONE
2) No subjects                      -- DONE
3) Is pinned but does not validate  -- Parlan
4) Duration is not valid            -- DONE
5) Is not of type CLIENT_AUTH       -- DONE
6.1) Issuer is not valid: hash algo=0
6.2) Issuer is not valid: no subjects
6.3) Issuer is not valid: is pinned but does not validate
6.4) Issuer is not valid: duration is not valid
6.5) Issuer is not valid: is not of type CERT_SIGNING
6.6) Issuer is not valid: is not in trusted store
6.7) Issuer is not valid: issuer is not valid=?
7) Signature is not valid                  -- DONE
8) Stapled certificate does not validate   -- Parlan
9) Queried certificate does not validate   -- Parlan
10) Stapled certificate does validate but has uncommon trust root -- Parlan
11) Queried certificate does validate but has uncommon trust root -- Parlan
'''

##################################################
############ Test valid client certs
##################################################
'''
1) Self-signed
2) Has issuer
'''

##################################################
############ 1) No Subjects
##################################################
def testInvalid1():
  print('In testInvalid1')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test1'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ 2) More Than One Subject
##################################################
def testInvalid2():
  print('In testInvalid2')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test2'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello', 'world'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ 4) Duration is not valid
##################################################
def testInvalid4():
  print('In testInvalid4')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test4'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 1
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ 5) Is not of type CLIENT_AUTH
##################################################
def testInvalid5():
  print('In testInvalid5')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test5'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([0])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')


##################################################
############ 6.1) More Than One Subject
##################################################
def testInvalid6():
  print('In testInvalid6')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test6.1'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = 0
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')


##################################################
############ 7) Signature is not valid
##################################################
def testInvalid7():
  print('In testInvalid7')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test7'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature
  nstp_msg.client_hello.certificate.valid_length = 2592001

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ Helper Functions
##################################################
def signCert(cert, is_self_signed):
  # Compute the sig over this cert
  state = bindings.crypto_sign_ed25519ph_state()

  # subject
  for subject in cert.subjects:
    bindings.crypto_sign_ed25519ph_update(state, subject.encode('UTF-8'))
  bindings.crypto_sign_ed25519ph_update(state, cert.valid_from.to_bytes(8, 'big'))
  bindings.crypto_sign_ed25519ph_update(state, cert.valid_length.to_bytes(4, 'big'))
  for usage in cert.usages:
    bindings.crypto_sign_ed25519ph_update(state, usage.to_bytes(1, 'big'))
  bindings.crypto_sign_ed25519ph_update(state, cert.encryption_public_key)
  bindings.crypto_sign_ed25519ph_update(state, cert.signing_public_key)
  if is_self_signed == False:
    bindings.crypto_sign_ed25519ph_update(state, cert.issuer.value)
    bindings.crypto_sign_ed25519ph_update(state, cert.issuer.algorithm.to_bytes(1, 'big'))

  return bindings.crypto_sign_ed25519ph_final_create(state, ca_private_key.signing_private_key)

def recvSafe(sock, msg_length):
  all_msg = b''
  while len(all_msg) < msg_length:
    tmp_recv = sock.recv(msg_length - len(all_msg))
    if len(tmp_recv) == 0:
      break
    all_msg += tmp_recv
  return all_msg

def printCertStores():
  test_file = open(sys.argv[1], "r")
  config_file = yaml.load(test_file, Loader=yaml.FullLoader)
  trusted_cert_store_loc  = config_file['trusted_certificate_store']
  pinned_cert_store_loc   = config_file['pinned_certificate_store']

  trusted_cert_store      = nstp_proto.CertificateStore()
  trusted_cert_store_file = open(trusted_cert_store_loc, "rb").read()
  trusted_cert_store.ParseFromString(trusted_cert_store_file)
  print('Trusted certificate store')
  print(trusted_cert_store)

  pinned_cert_store       = nstp_proto.PinnedCertificateStore()
  pinned_cert_store_file  = open(pinned_cert_store_loc, "rb").read()
  pinned_cert_store.ParseFromString(pinned_cert_store_file)
  print('Pinned certificate store')
  print(pinned_cert_store)


##################################################
############ Write to the pinned store
##################################################
'''
hello = open(pinned_cert_store_loc, "wb")
pinned_c_store = nstp_proto.PinnedCertificateStore()
pinned_c1 = nstp_proto.PinnedCertificate()
pinned_c1.subject = "127.0.0.1"
pinned_c1.certificate.value = b'JE<\x02C+q\x13V\xe4\x84\xb8\xc3^\x12\x16\xaaB\x95d\xde\xb7yl$\xf3\x9d=\x19\x1d.\x16\xf3p\xe3#<]\xf1\xabD\r\xca\xa0.\xf7\xc4\x1c\x93\xa8Jm\xcd\x12\x1fd\xa1\xd3q\x08\xee\x1f\xd5\xaa'
pinned_c1.certificate.algorithm = 2
pinned_c2 = nstp_proto.PinnedCertificate()
pinned_c2.subject = "127.0.0.1"
pinned_c2.certificate.value = b'JE<\002C+q\023V\344\204\270\303^\022\026\252B\225d\336\267yl$\363\235=\031\035.\026\363p\343#<]\361\253D\r\312\240.\367\304\034\223\250Jm\315\022\037d\241\323q\010\356\037\325\252'
pinned_c2.certificate.algorithm = 2
pinned_c_store.pinned_certificates.extend([pinned_c1, pinned_c2])

hello.write(pinned_c_store.SerializeToString())
hello.close()
'''


main()
