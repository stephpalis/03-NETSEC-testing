#! /usr/bin/env python3

############################################################################################
# ########### CLIENT FOR TESTING PURPOSES
############################################################################################
from enum import Enum
import sys
import yaml
import struct
import binascii
import nstp_v4_pb2 as nstp_proto
import nacl.bindings
import time
import hashlib
import socket
import subprocess
import threading


############################################################################################
# ########### SETUP: reading PKI files
############################################################################################
def read_data_file(file, protobuf):
    with open(file, 'rb') as f_server_file:
        b_server_file = f_server_file.read()
        protobuf.ParseFromString(b_server_file)


def write_data_file(file, protobuf):
    with open(file, 'wb') as f_server_file:
        f_server_file.write(protobuf.SerializeToString())


client_cert = nstp_proto.Certificate()
read_data_file("pki/client.crt", client_cert)

client_private_key = nstp_proto.PrivateKey()
read_data_file("pki/client.key", client_private_key)

ca_private_key = nstp_proto.PrivateKey()
read_data_file("pki/ca.key", ca_private_key)

trusted_store_orig = nstp_proto.CertificateStore()
read_data_file("pki/trusted_certs.db", trusted_store_orig)
ROOT_CERT = trusted_store_orig.certificates[0]

mod_trusted_store = nstp_proto.CertificateStore()
read_data_file("pki/mod_trusted_certs.db", mod_trusted_store)

status_cert = nstp_proto.Certificate()
read_data_file("pki/status.crt", status_cert)

status_private_key = nstp_proto.PrivateKey()
read_data_file("pki/status.key", status_private_key)

server_sock = None
status_sock = None
threads = []


############################################################################################
# ########### MAIN FUNCTION
############################################################################################
def main():
    global server_sock, status_sock
    # ============================================
    # SETUP: LEAVE THIS COMMENTED OUT
    #
    #trusted_list = setup_generate_updated_trust_store()
    ##setup_generate_certificates(trusted_list)
    #setup_generate_updated_pinned_store()
    # ============================================

    server_sock, status_sock = connect()
    test_invalid_1()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_2()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_3()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_4()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_5()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_610()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_611()
    expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_612()
    expect_error_msg_clear()

    # server_sock, status_sock = connect()
    # test_invalid_62()
    # expect_error_msg_clear()

    # server_sock, status_sock = connect()
    # test_invalid_63()
    # expect_error_msg_clear()

    server_sock, status_sock = connect()
    test_invalid_64()
    expect_error_msg_clear()

    # testInvalid65()
    # testInvalid7()
    # testInvalid8()
    # testInvalid9()  # Turn off your status server before
    # testInvalid10()
    # testInvalid11()  # Turn off your status server before

    # printCertStores()

    # After each test, receive the result
    # print('Receiving a new NSTPMessage')
    # nstp_msg = nstp_proto.NSTPMessage()
    # msg_length_recv = recv_safe(server_sock, 2)
    # msg_length = int(binascii.hexlify(msg_length_recv), 16)
    # print('msg_length=' + str(msg_length))
    # data = recv_safe(server_sock, msg_length)
    # nstp_msg.ParseFromString(data)
    # print('Received NSTPMessage:')
    # print(nstp_msg)

    print()
    print("#####" * 15)
    print("SUCCESSFULLY COMPLETED ALL TESTS")
    print("#####" * 15)

    for thread in threads:
        # This is specifically to force the program to stay open if the
        #   status server was launched by the client; this allows the
        #   user to kill the status server (ctrl + c) before exiting
        thread.join()


def connect():
    # Set up the server socket
    soc_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    soc_server.connect(("172.17.0.1", 22300))

    # Set up the status socket
    soc_status = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    soc_status.connect(("127.0.0.1", 22301))
    return soc_server, soc_status


############################################################################################
# ########### Test invalid client certs
############################################################################################
'''
1) More than one subject                                              -- DONE
2) No subjects                                                        -- DONE
3) Is pinned but does not validate                                    -- DONE
4) Duration is not valid                                              -- DONE
5) Is not of type CLIENT_AUTH                                         -- DONE
6.1) Issuer is not valid: hash algo=0                                 -- DONE
6.2) Issuer is not valid: no subjects                                 ** TBD (see slack)
6.3) Issuer is not valid: is pinned but does not validate             ** TBD
6.4) Issuer is not valid: duration is not valid
6.5) Issuer is not valid: is not of type CERT_SIGNING
6.6) Issuer is not valid: is not in trusted store
6.7) Issuer is not valid: issuer is not valid=?
7) Signature is not valid                                             -- DONE
8) Stapled certificate does not validate                              -- DONE
9) Queried certificate does not validate                              -- DONE
10) Stapled certificate does validate but has uncommon trust root     -- DONE
11) Queried certificate does validate but has uncommon trust root     -- DONE
'''

############################################################################################
# ########### Test valid client certs
############################################################################################
'''
1) Self-signed
2) Has issuer
'''


############################################################################################
# ########### 1) No Subjects
############################################################################################
def test_invalid_1():
    print()
    print("#####" * 15)
    print("[TEST INVALID 1]: client certificate with no subjects")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test1'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print("sent ClientHello")


############################################################################################
# ########### 2) More Than One Subject
############################################################################################
def test_invalid_2():
    print()
    print("#####" * 15)
    print("[TEST INVALID 2]: client certificate with more than one subject")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test2'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['hello', 'world'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 3) Is pinned but does not validate
############################################################################################
def test_invalid_3():
    print()
    print("#####" * 15)
    print("[TEST INVALID 3]: client certificate pinned but does not validate")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test3'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.CopyFrom(client_cert)
    nstp_msg.client_hello.certificate.valid_from = 1582603940

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 4) Duration is not valid
############################################################################################
def test_invalid_4():
    print()
    print("#####" * 15)
    print("[TEST INVALID 4]: client certificate time is invalid")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test4'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['hello'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 1
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 5) Is not of type CLIENT_AUTH
############################################################################################
def test_invalid_5():
    print()
    print("#####" * 15)
    print("[TEST INVALID 5]: client certificate missing usage CLIENT_AUTHENTICATION")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test5'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['hello'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([0])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 6.1.0) Issuer is not valid: hashed with identity
############################################################################################
def test_invalid_610():
    print()
    print("#####" * 15)
    print("[TEST INVALID 6.1.0]: client certificate issuer 'hashed' with identity")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test6.1.0'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['hello'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = ROOT_CERT.SerializeToString()
    nstp_msg.client_hello.certificate.issuer.algorithm = 0
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 6.1.1) Issuer is not valid: sha256 hash given with algorithm 0
############################################################################################
def test_invalid_611():
    print()
    print("#####" * 15)
    print("[TEST INVALID 6.1.1]: client certificate issuer hashed sha256, but listed identity")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test6.1.1'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['testing'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = 0
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 6.1.2) Issuer is not valid: sha256 hash given with algorithm 3
############################################################################################
def test_invalid_612():
    print()
    print("#####" * 15)
    print("[TEST INVALID 6.1.2]: client certificate issuer hashed sha256, but listed '3'")
    print("#####" * 15)
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test6.1.2'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['testing'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = 0
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 6.2) Issuer is not valid: no subjects
############################################################################################
def test_invalid_62():
    print()
    print("#####" * 15)
    print("[TEST INVALID 6.2]: client certificate issuer has no subjects")
    print("#####" * 15)
    issuer_62 = nstp_proto.Certificate()
    read_data_file("pki/trusted_62.crt", issuer_62)
    issuer_62_hash_algorithm = 2
    issuer_62_hash_value = hash_cert(issuer_62, issuer_62_hash_algorithm)

    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 0
    nstp_msg.client_hello.user_agent = 'test6.2'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['some_username'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = issuer_62_hash_value
    nstp_msg.client_hello.certificate.issuer.algorithm = issuer_62_hash_algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')


############################################################################################
# ########### 6.4) Issuer is not valid: invalid time
############################################################################################
def test_invalid_64():
    print()
    print("#####" * 15)
    print("[TEST INVALID 6.4]: client certificate issuer has cert has invalid time")
    print("#####" * 15)
    issuer_64 = nstp_proto.Certificate()
    read_data_file("pki/trusted_64.crt", issuer_64)
    issuer_64_hash_algorithm = 1
    issuer_64_hash_value = hash_cert(issuer_64, issuer_64_hash_algorithm)

    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 12
    nstp_msg.client_hello.user_agent = 'test6.4'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['anthr_one'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = issuer_64_hash_value
    nstp_msg.client_hello.certificate.issuer.algorithm = issuer_64_hash_algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('sent ClientHello')



############################################################################################
# ########### 6.5) Issuer is not valid: not CERT_SIGNING
############################################################################################
def generate65Certs(issuer_cert):
    client_certificate_65 = nstp_proto.Certificate()
    client_certificate_65.subjects.extend(['hello'])
    client_certificate_65.valid_from = 1582603941
    client_certificate_65.valid_length = 2592000
    client_certificate_65.usages.extend([1])
    client_certificate_65.encryption_public_key = client_cert.encryption_public_key
    client_certificate_65.signing_public_key = client_cert.signing_public_key

    client_certificate_65.issuer.value = hash_cert(issuer_cert, 1)
    client_certificate_65.issuer.algorithm = 1

    issuer_signature = sign_cert(client_certificate_65, False)
    client_certificate_65.issuer_signature = issuer_signature

    write_data_file("pki/client_65.crt", client_certificate_65)
    print("Successfully generated 'client_65.crt'")


def testInvalid65():
    print('Starting testInvalid65')

    status_thread = threading.Thread(target=start_status_server, args={"/data/status_65.crt"})
    threads.append(status_thread)
    status_thread.start()

    # Read the client certificate
    client_certificate_65 = nstp_proto.Certificate()
    read_data_file("/data/client_65.crt", client_certificate_65)

    # Create the ClientHello response
    nstp_msg_65 = nstp_proto.NSTPMessage()
    nstp_msg_65.client_hello.major_version = 4
    nstp_msg_65.client_hello.minor_version = 4444444
    nstp_msg_65.client_hello.user_agent = 'test6.5'
    nstp_msg_65.client_hello.certificate.CopyFrom(client_certificate_65)

    send_msg = nstp_msg_65.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)


############################################################################################
# ########### 7) Signature is not valid
############################################################################################
def testInvalid7():
    print('In testInvalid7')
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test7'

    # Parse the cert for the server
    nstp_msg.client_hello.certificate.subjects.extend(['hello'])
    nstp_msg.client_hello.certificate.valid_from = 1582603941
    nstp_msg.client_hello.certificate.valid_length = 2592000
    nstp_msg.client_hello.certificate.usages.extend([1])
    nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
    nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
    nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
    nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
    issuer_signature = sign_cert(nstp_msg.client_hello.certificate, False)
    nstp_msg.client_hello.certificate.issuer_signature = issuer_signature
    nstp_msg.client_hello.certificate.valid_length = 2592001

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', len(send_msg))
    server_sock.send(msg_length + send_msg)
    print('Sent ClientHello')


############################################################################################
# 8) Stapled certificate does not validate
############################################################################################
def testInvalid8():
    # certificate status is REVOKED

    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test8'

    nstp_msg.client_hello.certificate.CopyFrom(client_cert)
    nstp_msg.client_hello.certificate_status.certificate.value = create_hash(client_cert, hashlib.sha512())
    nstp_msg.client_hello.certificate_status.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
    nstp_msg.client_hello.certificate_status.status = nstp_proto.CertificateStatus.REVOKED
    nstp_msg.client_hello.certificate_status.valid_from = int(time.time())
    nstp_msg.client_hello.certificate_status.valid_length = 2592000
    nstp_msg.client_hello.certificate_status.status_certificate.CopyFrom(status_cert)
    nstp_msg.client_hello.certificate_status.status_signature = response_signature(nstp_msg.client_hello.certificate_status, status_private_key.signing_private_key)

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', nstp_msg.ByteSize())
    server_sock.send(msg_length + send_msg)
    print('Sent ClientHello')


############################################################################################
# 9) Queried certificate does not validate
############################################################################################
# make sure that there is no status server running for this test
# assumes your status server address is 127.0.0.1 / 22301

def testInvalid9():
    # create status server sock
    status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    status_sock.bind(('0.0.0.0', 22301))

    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test9'

    nstp_msg.client_hello.certificate.CopyFrom(client_cert)

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', nstp_msg.ByteSize())
    server_sock.send(msg_length + send_msg)
    print('Sent ClientHello')

    data, addr = status_sock.recvfrom(1024)
    req = nstp_proto.CertificateStatusRequest()
    req.ParseFromString(data)
    print("req")
    print(req)

    resp = nstp_proto.CertificateStatusResponse()
    resp.certificate.CopyFrom(req.certificate)
    resp.status = nstp_proto.CertificateStatus.REVOKED
    resp.valid_from = int(time.time())
    resp.valid_length = 2592000
    resp.status_certificate.CopyFrom(status_cert)
    resp.status_signature = response_signature(resp, status_private_key.signing_private_key)
    print("resp")
    print(resp)

    status_sock.sendto(resp.SerializeToString(), addr)
    print('Sent CertificateStatusResponse')


############################################################################################
# 10) Stapled certificate does validate but has uncommon trust root
############################################################################################
def testInvalid10():
    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test10'

    other_ca = nstp_proto.Certificate()
    other_ca.CopyFrom(mod_trusted_store.certificates[1])

    nstp_msg.client_hello.certificate.CopyFrom(client_cert)
    nstp_msg.client_hello.certificate_status.certificate.value = create_hash(client_cert, hashlib.sha512())
    nstp_msg.client_hello.certificate_status.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
    nstp_msg.client_hello.certificate_status.status = nstp_proto.CertificateStatus.VALID
    nstp_msg.client_hello.certificate_status.valid_from = int(time.time())
    nstp_msg.client_hello.certificate_status.valid_length = 2592000
    nstp_msg.client_hello.certificate_status.status_certificate.CopyFrom(status_cert)
    nstp_msg.client_hello.certificate_status.status_certificate.issuer.value = create_hash(other_ca, hashlib.sha512())
    nstp_msg.client_hello.certificate_status.status_certificate.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
    nstp_msg.client_hello.certificate_status.status_certificate.issuer_signature = cert_signature(nstp_msg.client_hello.certificate_status.status_certificate,
                                                                                                  ca_private_key.signing_private_key)
    nstp_msg.client_hello.certificate_status.status_signature = response_signature(nstp_msg.client_hello.certificate_status, status_private_key.signing_private_key)

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', nstp_msg.ByteSize())
    server_sock.send(msg_length + send_msg)
    print('Sent ClientHello')


############################################################################################
# 11) Queried certificate does validate but has uncommon trust root
############################################################################################
# make sure that there is no status server running for this test
# assumes your status server address is 127.0.0.1 / 22301

def testInvalid11():
    # create status server sock
    status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    status_sock.bind(('0.0.0.0', 22301))

    # Create the ClientHello response
    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.client_hello.major_version = 4
    nstp_msg.client_hello.minor_version = 4444444
    nstp_msg.client_hello.user_agent = 'test11'
    nstp_msg.client_hello.certificate.CopyFrom(client_cert)

    other_ca = nstp_proto.Certificate()
    other_ca.CopyFrom(ROOT_CERT)

    send_msg = nstp_msg.SerializeToString()
    msg_length = struct.pack('!H', nstp_msg.ByteSize())
    server_sock.send(msg_length + send_msg)
    print('Sent ClientHello')

    data, addr = status_sock.recvfrom(1024)
    req = nstp_proto.CertificateStatusRequest()
    req.ParseFromString(data)

    resp = nstp_proto.CertificateStatusResponse()
    resp.certificate.CopyFrom(req.certificate)
    resp.status = nstp_proto.CertificateStatus.VALID
    resp.valid_from = int(time.time())
    resp.valid_length = 2592000
    resp.status_certificate.CopyFrom(status_cert)
    resp.status_certificate.issuer.value = create_hash(other_ca, hashlib.sha512())
    resp.status_certificate.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
    resp.status_certificate.issuer_signature = cert_signature(resp.status_certificate, ca_private_key.signing_private_key)
    resp.status_signature = response_signature(resp, status_private_key.signing_private_key)

    status_sock.sendto(resp.SerializeToString(), addr)
    print('Sent CertificateStatusResponse')


############################################################################################
# ########### RESPONSE FUNCTIONS
############################################################################################
class Message(Enum):
    CLIENT_HELLO = "client_hello"
    SERVER_HELLO = "server_hello"
    ERROR_MSG = "error_message"
    ENCRYPTED_MSG = "encrypted_message"


def expect_error_msg_clear():
    global server_sock
    nstp_msg, nstp_msg_type = recv_nstp_msg(server_sock)
    assert nstp_msg_type == Message.ERROR_MSG
    print("response type:", nstp_msg_type)
    assert nstp_msg_type == Message.ERROR_MSG
    print("received error:", nstp_msg.error_message.error_message)


def recv_nstp_msg(client_soc: socket.socket):
    b_msg_len = recv_all(client_soc, 2)
    if len(b_msg_len) < 2:
        return b""

    msg_len = struct.unpack("!H", b_msg_len)[0]
    print("reading [{}] bytes".format(msg_len))
    b_msg = recv_all(client_soc, msg_len)
    if len(b_msg) < 2:
        return b""

    nstp_msg = nstp_proto.NSTPMessage()
    nstp_msg.ParseFromString(b_msg)
    nstp_msg_type_value = nstp_msg.WhichOneof("message_")
    try:
        nstp_msg_type = Message(nstp_msg_type_value)
    except Exception as e:
        print("unknown event occurred:", e)
        nstp_msg_type = nstp_msg_type_value
    return nstp_msg, nstp_msg_type


def recv_all(client_soc: socket.socket, num: int):
    b_msg = b""
    while len(b_msg) < num:
        b_piece = client_soc.recv(num - len(b_msg))
        if len(b_piece) == 0:
            break
        b_msg += b_piece
    return b_msg


############################################################################################
# ########### HELPER FUNCTIONS
############################################################################################
def create_issuer_cert(subjects, start, length, usage):
    certificate = nstp_proto.Certificate()
    if subjects:
        certificate.subjects.extend(["sub1"])
    certificate.valid_from = start
    certificate.valid_length = length
    certificate.usages.append(usage)
    # certificate.encryption_public_key = bytes(PrivateKey.generate().public_key)
    # certificate.signing_public_key = bytes(PrivateKey.generate().public_key)
    certificate.encryption_public_key = ROOT_CERT.encryption_public_key
    certificate.signing_public_key = ROOT_CERT.signing_public_key
    certificate.issuer_signature = sign_cert(certificate, True)
    return certificate


def sign_cert(cert, is_self_signed, private_key=None):
    if private_key is None:
        # print('private_key is none')
        # print(ca_private_key.signing_private_key)
        # print(ca_private_key)
        private_key = ca_private_key.signing_private_key

    # Compute the sig over this cert
    state = nacl.bindings.crypto_sign_ed25519ph_state()

    # subject
    for subject in cert.subjects:
        nacl.bindings.crypto_sign_ed25519ph_update(state, subject.encode('UTF-8'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_from.to_bytes(8, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_length.to_bytes(4, 'big'))
    for usage in cert.usages:
        nacl.bindings.crypto_sign_ed25519ph_update(state, usage.to_bytes(1, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.encryption_public_key)
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.signing_public_key)
    if is_self_signed is False:
        nacl.bindings.crypto_sign_ed25519ph_update(state, cert.issuer.value)
        nacl.bindings.crypto_sign_ed25519ph_update(state, cert.issuer.algorithm.to_bytes(1, 'big'))
    return nacl.bindings.crypto_sign_ed25519ph_final_create(state, private_key)


def create_hash(cert: nstp_proto.Certificate, hasher):
    for subject in cert.subjects:
        hasher.update(subject.encode('UTF-8'))
    hasher.update(cert.valid_from.to_bytes(8, 'big'))
    hasher.update(cert.valid_length.to_bytes(4, 'big'))
    for usage in cert.usages:
        if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
            hasher.update((0).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
            hasher.update((1).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
            hasher.update((2).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
            hasher.update((3).to_bytes(1, 'big'))
    hasher.update(cert.encryption_public_key)
    hasher.update(cert.signing_public_key)
    if cert.HasField("issuer"):
        hasher.update(cert.issuer.value)
        if cert.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
            hasher.update((0).to_bytes(1, 'big'))
        elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
            hasher.update((1).to_bytes(1, 'big'))
        elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
            hasher.update((2).to_bytes(1, 'big'))
    hasher.update(cert.issuer_signature)

    return hasher.digest()


def cert_signature(cert: nstp_proto.Certificate, signing_key):
    state = nacl.bindings.crypto_sign_ed25519ph_state()
    for subject in cert.subjects:
        nacl.bindings.crypto_sign_ed25519ph_update(state, subject.encode("UTF-8"))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_from.to_bytes(8, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_length.to_bytes(4, 'big'))
    for usage in cert.usages:
        if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (3).to_bytes(1, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.encryption_public_key)
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.signing_public_key)
    if cert.HasField("issuer"):
        nacl.bindings.crypto_sign_ed25519ph_update(state, cert.issuer.value)
        if cert.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
        elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
        elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    return nacl.bindings.crypto_sign_ed25519ph_final_create(state, signing_key)


def response_signature(resp: nstp_proto.CertificateStatusResponse, signing_key):
    state = nacl.bindings.crypto_sign_ed25519ph_state()
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.certificate.value)
    if resp.certificate.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif resp.certificate.algorithm is nstp_proto.HashAlgorithm.SHA256:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif resp.certificate.algorithm is nstp_proto.HashAlgorithm.SHA512:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    if resp.status is nstp_proto.CertificateStatus.UNKNOWN:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif resp.status is nstp_proto.CertificateStatus.VALID:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif resp.status is nstp_proto.CertificateStatus.REVOKED:
        nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.valid_from.to_bytes(8, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.valid_length.to_bytes(4, 'big'))

    for subject in resp.status_certificate.subjects:
        nacl.bindings.crypto_sign_ed25519ph_update(state, subject.encode("UTF-8"))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.valid_from.to_bytes(8, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.valid_length.to_bytes(4, 'big'))
    for usage in resp.status_certificate.usages:
        if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
        elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (3).to_bytes(1, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.encryption_public_key)
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.signing_public_key)
    if resp.status_certificate.HasField("issuer"):
        nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.issuer.value)
        if resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
        elif resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
        elif resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
            nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.issuer_signature)

    return nacl.bindings.crypto_sign_ed25519ph_final_create(state, signing_key)


def recv_safe(sock, msg_length):
    all_msg = b''
    while len(all_msg) < msg_length:
        tmp_recv = sock.recv(msg_length - len(all_msg))
        if len(tmp_recv) == 0:
            break
        all_msg += tmp_recv
    return all_msg


def print_cert_store():
    test_file = open(sys.argv[1], "r")
    config_file = yaml.load(test_file, Loader=yaml.FullLoader)
    trusted_cert_store_loc = config_file['trusted_certificate_store']
    pinned_cert_store_loc = config_file['pinned_certificate_store']

    trusted_cert_store = nstp_proto.CertificateStore()
    trusted_cert_store_file = open(trusted_cert_store_loc, "rb").read()
    trusted_cert_store.ParseFromString(trusted_cert_store_file)
    print('Trusted certificate store')
    print(trusted_cert_store)

    pinned_cert_store = nstp_proto.PinnedCertificateStore()
    pinned_cert_store_file = open(pinned_cert_store_loc, "rb").read()
    pinned_cert_store.ParseFromString(pinned_cert_store_file)
    print('Pinned certificate store')
    print(pinned_cert_store)


def bytes_of_fields(msg):
    packed = b''
    for i in msg.subjects:
        packed += i.encode("UTF-8")
    packed += msg.valid_from.to_bytes(8, "big")
    packed += msg.valid_length.to_bytes(4, "big")
    for i in msg.usages:
        packed += i.to_bytes(1, "big")
    packed += msg.encryption_public_key
    packed += msg.signing_public_key
    if msg.HasField("issuer"):
        packed += msg.issuer.value
        packed += msg.issuer.algorithm.to_bytes(1, "big")
    return packed


def hash_cert(certificate, algorithm):
    packed = bytes_of_fields(certificate)
    if certificate.issuer_signature != b'':
        packed += certificate.issuer_signature
    if algorithm == 1:
        hashed = hashlib.sha256(packed)
    elif algorithm == 2:
        hashed = hashlib.sha512(packed)
    else:
        hashed = None  # this shouldn't happen
    return hashed.digest()


def start_status_server(stats_crt):
    cmd = "java -jar nstp-cert-status-server.jar " + \
          "--certificate {} ".format(stats_crt) + \
          "--key /data/status.key " + \
          "--allow /data/client.crt " + \
          "--allow /data/server.crt " + \
          "--print " + \
          "--allow /data/trusted_62.crt " + \
          "--allow /data/trusted_63.crt " + \
          "--allow /data/trusted_64.crt " + \
          "--allow /data/trusted_65.crt " + \
          "--allow /data/trusted_66.crt " + \
          "--allow /data/trusted_67.crt " + \
          "--allow /data/client_65.crt "
    print("STARTING STATUS SERVER")
    subprocess.run(cmd.strip().split())
    time.sleep(1)


############################################################################################
# ########### SETUP (trusted, pinned, status)
############################################################################################
def setup_generate_updated_status_cert(trusted_cert, new_status_crt_file):
    updated_status_cert = nstp_proto.Certificate()
    read_data_file("pki/status.crt", updated_status_cert)
    trusted_hash = hash_cert(trusted_cert, 1)
    updated_status_cert.issuer.value = trusted_hash
    updated_status_cert.issuer.algorithm = 1
    updated_status_cert.issuer_signature = sign_cert(updated_status_cert, False)
    write_data_file(new_status_crt_file, updated_status_cert)


def setup_generate_updated_pinned_store():
    pinned_certificates = nstp_proto.PinnedCertificateStore()
    read_data_file("pki/mod_pinned_certs.db", pinned_certificates)

    status_cert_orig = nstp_proto.Certificate()
    status_cert_62 = nstp_proto.Certificate()
    status_cert_63 = nstp_proto.Certificate()
    status_cert_64 = nstp_proto.Certificate()
    status_cert_65 = nstp_proto.Certificate()
    status_cert_66 = nstp_proto.Certificate()
    status_cert_67 = nstp_proto.Certificate()

    read_data_file("pki/status.crt", status_cert_orig)
    read_data_file("pki/status_62.crt", status_cert_62)
    read_data_file("pki/status_63.crt", status_cert_63)
    read_data_file("pki/status_64.crt", status_cert_64)
    read_data_file("pki/status_65.crt", status_cert_65)
    read_data_file("pki/status_66.crt", status_cert_66)
    read_data_file("pki/status_67.crt", status_cert_67)

    cert_hash_orig = nstp_proto.CertificateHash()
    cert_hash_62 = nstp_proto.CertificateHash()
    cert_hash_63 = nstp_proto.CertificateHash()
    cert_hash_64 = nstp_proto.CertificateHash()
    cert_hash_65 = nstp_proto.CertificateHash()
    cert_hash_66 = nstp_proto.CertificateHash()
    cert_hash_67 = nstp_proto.CertificateHash()

    cert_hash_orig.algorithm = 2
    cert_hash_62.algorithm = 2
    cert_hash_63.algorithm = 2
    cert_hash_64.algorithm = 2
    cert_hash_65.algorithm = 2
    cert_hash_66.algorithm = 2
    cert_hash_67.algorithm = 2

    cert_hash_orig.value = hash_cert(status_cert_orig, 2)
    cert_hash_62.value = hash_cert(status_cert_62, 2)
    cert_hash_63.value = hash_cert(status_cert_63, 2)
    cert_hash_64.value = hash_cert(status_cert_64, 2)
    cert_hash_65.value = hash_cert(status_cert_65, 2)
    cert_hash_66.value = hash_cert(status_cert_66, 2)
    cert_hash_67.value = hash_cert(status_cert_67, 2)

    pin_orig = nstp_proto.PinnedCertificate()
    pin_62 = nstp_proto.PinnedCertificate()
    pin_63 = nstp_proto.PinnedCertificate()
    pin_64 = nstp_proto.PinnedCertificate()
    pin_65 = nstp_proto.PinnedCertificate()
    pin_66 = nstp_proto.PinnedCertificate()
    pin_67 = nstp_proto.PinnedCertificate()

    pin_orig.subject = "127.0.0.1"
    pin_62.subject = "127.0.0.1"
    pin_63.subject = "127.0.0.1"
    pin_64.subject = "127.0.0.1"
    pin_65.subject = "127.0.0.1"
    pin_66.subject = "127.0.0.1"
    pin_67.subject = "127.0.0.1"

    pin_orig.certificate.CopyFrom(cert_hash_orig)
    pin_62.certificate.CopyFrom(cert_hash_62)
    pin_63.certificate.CopyFrom(cert_hash_63)
    pin_64.certificate.CopyFrom(cert_hash_64)
    pin_65.certificate.CopyFrom(cert_hash_65)
    pin_66.certificate.CopyFrom(cert_hash_66)
    pin_67.certificate.CopyFrom(cert_hash_67)

    pinned_certificates.pinned_certificates.append(pin_orig)
    pinned_certificates.pinned_certificates.append(pin_62)
    pinned_certificates.pinned_certificates.append(pin_63)
    pinned_certificates.pinned_certificates.append(pin_64)
    pinned_certificates.pinned_certificates.append(pin_65)
    pinned_certificates.pinned_certificates.append(pin_66)
    pinned_certificates.pinned_certificates.append(pin_67)

    write_data_file("pki/pinned_certs_v2.db", pinned_certificates)
    print("Successfully updated pinned store")


def setup_generate_updated_trust_store():
    trusted_certificate_store = nstp_proto.CertificateStore()
    read_data_file("pki/mod_trusted_certs.db", trusted_certificate_store)

    issuer_62 = create_issuer_cert(False, 1582603941, 2592000, 0)
    issuer_63 = create_issuer_cert(True, 0, 0, 0)  # TODO
    issuer_64 = create_issuer_cert(True, 0, 0, 0)
    issuer_65 = create_issuer_cert(True, 1582603941, 2592000, 1)
    issuer_66 = create_issuer_cert(True, 0, 0, 0)  # TODO
    issuer_67 = create_issuer_cert(True, 0, 0, 0)  # TODO

    list_trusted = (issuer_62, issuer_63, issuer_64, issuer_65, issuer_66, issuer_67)
    for trusted_cert in list_trusted:
        trusted_certificate_store.certificates.append(trusted_cert)

    write_data_file("pki/trusted_certs_v2.db", trusted_certificate_store)
    write_data_file("pki/trusted_62.crt", issuer_62)
    write_data_file("pki/trusted_63.crt", issuer_63)
    write_data_file("pki/trusted_64.crt", issuer_64)
    write_data_file("pki/trusted_65.crt", issuer_65)
    write_data_file("pki/trusted_66.crt", issuer_66)
    write_data_file("pki/trusted_67.crt", issuer_67)

    setup_generate_updated_status_cert(issuer_62, "pki/status_62.crt")
    setup_generate_updated_status_cert(issuer_63, "pki/status_63.crt")
    setup_generate_updated_status_cert(issuer_64, "pki/status_64.crt")
    setup_generate_updated_status_cert(issuer_65, "pki/status_65.crt")
    setup_generate_updated_status_cert(issuer_66, "pki/status_66.crt")
    setup_generate_updated_status_cert(issuer_67, "pki/status_67.crt")

    print("Successfully updated trust store")
    return list_trusted


def setup_generate_certificates(trusted_list):
    six_two, six_three, six_four, six_five, six_six, six_seven = trusted_list
    generate65Certs(six_five)


# ====================================================================================
# hello = open(pinned_cert_store_loc, "wb")
# pinned_c_store = nstp_proto.PinnedCertificateStore()
# pinned_c1 = nstp_proto.PinnedCertificate()
# pinned_c1.subject = "127.0.0.1"
# pinned_c1.certificate.value = b'JE<\x02C+q\x13V\xe4\x84\xb8\xc3^\x12\x16\xaaB\x95d\xde\xb7yl$\xf3\x9d=\x19\x1d.\x16\xf3p\xe3#<]\xf1\xabD\r\xca\xa0.\xf7\xc4\x1c\x93\xa8Jm\xcd\x12\x1fd\xa1\xd3q\x08\xee\x1f\xd5\xaa'
# pinned_c1.certificate.algorithm = 2
# pinned_c2 = nstp_proto.PinnedCertificate()
# pinned_c2.subject = "127.0.0.1"
# pinned_c2.certificate.value = b'JE<\002C+q\023V\344\204\270\303^\022\026\252B\225d\336\267yl$\363\235=\031\035.\026\363p\343#<]\361\253D\r\312\240.\367\304\034\223\250Jm\315\022\037d\241\323q\010\356\037\325\252'
# pinned_c2.certificate.algorithm = 2
# pinned_c_store.pinned_certificates.extend([pinned_c1, pinned_c2])
# hello.write(pinned_c_store.SerializeToString())
# hello.close()
# ====================================================================================
# other_ca = nstp_proto.Certificate()
# other_ca.CopyFrom(trusted_cert_store.certificates[0])
# other_ca.subjects.extend(["other_ca"])
# other_ca.issuer_signature = cert_signature(other_ca, ca_private_key.signing_private_key)

# hello = open("/data/mod_pinned_certs.db", "wb+")
# pinned_c_store = nstp_proto.PinnedCertificateStore()
# pinned_c1 = nstp_proto.PinnedCertificate()
# pinned_c1.subject = status_cert.subjects[0]
# pinned_c1.certificate.value = create_hash(status_cert, hashlib.sha512())
# pinned_c1.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_c2 = nstp_proto.PinnedCertificate()
# pinned_c2.subject = client_cert.subjects[0]
# pinned_c2.certificate.value = create_hash(client_cert, hashlib.sha512())
# pinned_c2.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_cert3 = nstp_proto.Certificate()
# pinned_cert3.CopyFrom(status_cert)
# pinned_cert3.issuer.value = create_hash(other_ca, hashlib.sha512())
# pinned_cert3.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_cert3.issuer_signature = cert_signature(pinned_cert3, ca_private_key.signing_private_key)
# pinned_c3 = nstp_proto.PinnedCertificate()
# pinned_c3.subject = status_cert.subjects[0]
# pinned_c3.certificate.value = create_hash(pinned_cert3, hashlib.sha512())
# pinned_c3.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_cert4 = nstp_proto.Certificate()
# pinned_cert4.CopyFrom(status_cert)
# pinned_cert4.issuer.value = create_hash(other_ca, hashlib.sha512())
# pinned_cert4.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_cert4.issuer_signature = cert_signature(pinned_cert4, ca_private_key.signing_private_key)
# pinned_c4 = nstp_proto.PinnedCertificate()
# pinned_c4.subject = status_cert.subjects[0]
# pinned_c4.certificate.value = create_hash(pinned_cert4, hashlib.sha512())
# pinned_c4.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
# pinned_c_store.pinned_certificates.extend([pinned_c1, pinned_c2, pinned_c3, pinned_c4])

# hello.write(pinned_c_store.SerializeToString())
# hello.close()

# hello = open("/data/mod_trusted_certs.db", "wb+")
# trusted_cert_store.certificates.extend([other_ca])
# hello.write(trusted_cert_store.SerializeToString())
# hello.close()

# print("writing to file")
# print(pinned_c_store)
# print(trusted_cert_store)
# ====================================================================================
############################################################################################


main()
time.sleep(1)
