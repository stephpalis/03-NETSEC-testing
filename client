#! /usr/bin/env python3
##################################################
############ CLIENT FOR TESTING PURPOSES
##################################################
import sys, yaml, socket, struct
import nstp_v4_pb2 as nstp_proto
import nacl.bindings
import time
import hashlib
import socket

client_cert_file = open("/data/client.crt", "rb").read()
client_cert      = nstp_proto.Certificate()
client_cert.ParseFromString(client_cert_file)

client_private_key_file = open("/data/client.key", "rb").read()
client_private_key      = nstp_proto.PrivateKey()
client_private_key.ParseFromString(client_private_key_file)

ca_private_key_file = open("/data/ca.key", "rb").read()
ca_private_key      = nstp_proto.PrivateKey()
ca_private_key.ParseFromString(ca_private_key_file)

with open("/data/status.crt", "rb") as status_cert_file:
  status_cert = nstp_proto.Certificate()
  status_cert.ParseFromString(status_cert_file.read())

with open("/data/status.key", "rb") as status_private_key_file:
  status_private_key = nstp_proto.PrivateKey()
  status_private_key.ParseFromString(status_private_key_file.read())

# Set up the server socket
server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_sock.connect(("127.0.0.1", 22300))
# Set up the status socket
status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
status_sock.connect(("127.0.0.1", 22301))


def main():
  # testInvalid1()
  # testInvalid2()
  # testInvalid3()
  # testInvalid4()
  testInvalid8()
  # testInvalid9()
  # testInvalid10()
  # testInvalid11()

##################################################
############ Test invalid client certs
##################################################
'''
1) More than one subject            -- DONE
2) No subjects                      -- DONE
3) Is pinned but does not validate
4) Duration is not valid
5) Is not of type CLIENT_AUTH
6.1) Issuer is not valid: hash algo=0
6.2) Issuer is not valid: no subjects
6.3) Issuer is not valid: is pinned but does not validate
6.4) Issuer is not valid: duration is not valid
6.5) Issuer is not valid: is not of type CERT_SIGNING
6.6) Issuer is not valid: is not in trusted store
6.7) Issuer is not valid: issuer is not valid=?
7) Signature is not valid
8) Stapled certificate does not validate
9) Queried certificate does not validate
10) Stapled certificate does validate but has uncommon trust root
11) Queried certificate does validate but has uncommon trust root
'''

##################################################
############ Test valid client certs
##################################################
'''
1) Self-signed
2) Has issuer
'''

##################################################
############ Print Cert Stores
##################################################
test_file = open(sys.argv[1], "r")
config_file = yaml.load(test_file, Loader=yaml.FullLoader)
trusted_cert_store_loc  = config_file['trusted_certificate_store']
pinned_cert_store_loc   = config_file['pinned_certificate_store']

trusted_cert_store      = nstp_proto.CertificateStore()
trusted_cert_store_file = open(trusted_cert_store_loc, "rb").read()
trusted_cert_store.ParseFromString(trusted_cert_store_file)
print('Trusted certificate store')
print(trusted_cert_store)

pinned_cert_store       = nstp_proto.PinnedCertificateStore()
pinned_cert_store_file  = open(pinned_cert_store_loc, "rb").read()
pinned_cert_store.ParseFromString(pinned_cert_store_file)
print('Pinned certificate store')
print(pinned_cert_store)

##################################################
############ 1) No Subjects
##################################################
def testInvalid1():
  print('In testInvalid1')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test1'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ 2) More Than One Subject
##################################################
def testInvalid2():
  print('In testInvalid2')
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test2'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello', 'world'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 2592000
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
############ 3) Is pinned but does not validate
##################################################
# uses same subjects as pinned cert, but an extra usage
# if you validate usage before checking pinned certs, use the other version

def testInvalid3():
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test3'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.CopyFrom(client_cert)
  nstp_msg.client_hello.certificate.usages.extend([2])

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')


# this option has a wrong time
# if this still doesnt work for you then just check pinned certs earlier i guess
'''
def testInvalid3():
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test3'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.CopyFrom(client_cert)
  nstp_msg.client_hello.certificate.valid_from = 0

  send_msg = nstp_msg.SerializeToString()
  msg_lengnth = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')
'''
##################################################
############ 4) Duration is not valid
##################################################
def testInvalid4():
  print('In testInvalid4')
  nstp_msg.client_hello.user_agent = 'test2'

  # Parse the cert for the server
  nstp_msg.client_hello.certificate.subjects.extend(['hello'])
  nstp_msg.client_hello.certificate.valid_from = 1582603941
  nstp_msg.client_hello.certificate.valid_length = 1
  nstp_msg.client_hello.certificate.usages.extend([1])
  nstp_msg.client_hello.certificate.encryption_public_key = client_cert.encryption_public_key
  nstp_msg.client_hello.certificate.signing_public_key = client_cert.signing_public_key
  nstp_msg.client_hello.certificate.issuer.value = client_cert.issuer.value
  nstp_msg.client_hello.certificate.issuer.algorithm = client_cert.issuer.algorithm
  issuer_signature = signCert(nstp_msg.client_hello.certificate, False)
  nstp_msg.client_hello.certificate.issuer_signature = issuer_signature

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', len(send_msg))
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')


##################################################
# 8) Stapled certificate does not validate
##################################################
def testInvalid8():
  # certificate status is REVOKED

  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test8'

  nstp_msg.client_hello.certificate.CopyFrom(client_cert)
  nstp_msg.client_hello.certificate_status.certificate.value = create_hash(client_cert, hashlib.sha512())
  nstp_msg.client_hello.certificate_status.certificate.algorithm = 3
  print("for comparison")
  print(nstp_msg.client_hello.certificate_status.certificate)
  nstp_msg.client_hello.certificate_status.status = 2
  nstp_msg.client_hello.certificate_status.valid_from = int(time.time())
  nstp_msg.client_hello.certificate_status.valid_length = 2592000
  nstp_msg.client_hello.certificate_status.status_certificate.CopyFrom(status_cert)
  nstp_msg.client_hello.certificate_status.status_signature = response_signature(nstp_msg.client_hello.certificate_status, status_private_key.signing_private_key)

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', nstp_msg.ByteSize())
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

##################################################
# 9) Queried certificate does not validate
##################################################
# make sure that there is no status server running for this test
# assumes your status server address is 127.0.0.1 / 22301

def testInvalid9():
  # create status server sock
  status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  status_sock.bind(('0.0.0.0', 22301))

  time.sleep(10)
  # during this time you should start up your nstp server
  # not sure about you guys but my implementation needs the status
  # server to be up before starting the nstp server


  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test9'

  nstp_msg.client_hello.certificate.CopyFrom(client_cert)

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', nstp_msg.ByteSize())
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

  
  data, addr = status_sock.recvfrom(1024)
  req = nstp_proto.CertificateStatusRequest()
  req.ParseFromString(data)

  resp = nstp_proto.CertificateStatusResponse()
  resp.certificate.CopyFrom(req.certificate)
  resp.status = 2
  resp.valid_from = int(time.time())
  resp.valid_length = 2592000
  resp.status_certificate.CopyFrom(status_cert)
  resp.status_signature = response_signature(resp, status_private_key.signing_private_key)

  status_sock.sendto(resp.SerializeToString(), addr)
  print('Sent CertificateStatusResponse')

##################################################
# 10) Stapled certificate does validate but has uncommon trust root
##################################################
# note that the issuer CertificateHash will not validate as its not a real trust root
# you should move up the logic that compares trust roots for this test
# or comment out your issuer validation in CertificateStatusResponse handling

def testInvalid10():
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test10'

  nstp_msg.client_hello.certificate.CopyFrom(client_cert)
  nstp_msg.client_hello.certificate_status.certificate.value = create_hash(client_cert, hashlib.sha512())
  nstp_msg.client_hello.certificate_status.certificate.algorithm = 3
  nstp_msg.client_hello.certificate_status.status = 1
  nstp_msg.client_hello.certificate_status.valid_from = int(time.time())
  nstp_msg.client_hello.certificate_status.valid_length = 2592000
  nstp_msg.client_hello.certificate_status.status_certificate.CopyFrom(status_cert)
  # vvvvvvvv this is the line i'm talking about
  nstp_msg.client_hello.certificate_status.status_certificate.issuer.value = hashlib.sha512("foo".encode('UTF-8')).digest()
  nstp_msg.client_hello.certificate_status.status_certificate.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
  nstp_msg.client_hello.certificate_status.status_signature = response_signature(nstp_msg.client_hello.certificate_status, status_private_key.signing_private_key)

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', nstp_msg.ByteSize())
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')


##################################################
# 11) Queried certificate does validate but has uncommon trust root
##################################################
# make sure that there is no status server running for this test
# assumes your status server address is 127.0.0.1 / 22301

# same restrictions as test 10

def testInvalid11():
  # Create the ClientHello response
  nstp_msg = nstp_proto.NSTPMessage()
  nstp_msg.client_hello.major_version = 4
  nstp_msg.client_hello.minor_version = 4444444
  nstp_msg.client_hello.user_agent = 'test11'

  nstp_msg.client_hello.certificate.CopyFrom(client_cert)

  send_msg = nstp_msg.SerializeToString()
  msg_length = struct.pack('!H', nstp_msg.ByteSize())
  server_sock.send(msg_length + send_msg)
  print('Sent ClientHello')

  status_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
  status_sock.bind(('0.0.0.0', 22301))
  data, addr = status_sock.recvfrom(1024)
  req = nstp_proto.CertificateStatusRequest()
  req.ParseFromString(data)

  resp = nstp_proto.CertificateStatusResponse()
  resp.certificate.CopyFrom(req.certificate)
  resp.status = nstp_proto.CertificateStatus.VALID
  resp.valid_from = int(time.time())
  resp.valid_length = 2592000
  resp.status_certificate.CopyFrom(status_cert)
  resp.status_certificate.issuer.value = hashlib.sha512("foo".encode('UTF-8'))
  resp.status_certificate.issuer.algorithm = nstp_proto.HashAlgorithm.SHA512
  resp.status_signature = response_signature(resp, status_private_key.signing_private_key)

  status_sock.sendto(resp.SerializeToString(), addr)
  print('Sent CertificateStatusResponse')


##################################################
############ Helper Functions
##################################################
def signCert(cert, is_self_signed):
  # Compute the sig over this cert
  state = bindings.crypto_sign_ed25519ph_state()

  # subject
  for subject in cert.subjects:
    bindings.crypto_sign_ed25519ph_update(state, subject.encode('UTF-8'))
  bindings.crypto_sign_ed25519ph_update(state, cert.valid_from.to_bytes(8, 'big'))
  bindings.crypto_sign_ed25519ph_update(state, cert.valid_length.to_bytes(4, 'big'))
  for usage in cert.usages:
    bindings.crypto_sign_ed25519ph_update(state, usage.to_bytes(1, 'big'))
  bindings.crypto_sign_ed25519ph_update(state, cert.encryption_public_key)
  bindings.crypto_sign_ed25519ph_update(state, cert.signing_public_key)
  if is_self_signed == False:
    bindings.crypto_sign_ed25519ph_update(state, cert.issuer.value)
    bindings.crypto_sign_ed25519ph_update(state, cert.issuer.algorithm.to_bytes(1, 'big'))

  return bindings.crypto_sign_ed25519ph_final_create(state, ca_private_key.signing_private_key)


def create_hash(cert: nstp_proto.Certificate, hasher):
  for subject in cert.subjects:
    hasher.update(subject.encode('UTF-8'))
  hasher.update(cert.valid_from.to_bytes(8, 'big'))
  hasher.update(cert.valid_length.to_bytes(4, 'big'))
  for usage in cert.usages:
    if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
      hasher.update((0).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
      hasher.update((1).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
      hasher.update((2).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
      hasher.update((3).to_bytes(1, 'big'))
  hasher.update(cert.encryption_public_key)
  hasher.update(cert.signing_public_key)
  if cert.HasField("issuer"):
    hasher.update(cert.issuer.value)
    if cert.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
      hasher.update((0).to_bytes(1, 'big'))
    elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
      hasher.update((1).to_bytes(1, 'big'))
    elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
      hasher.update((2).to_bytes(1, 'big'))
  hasher.update(cert.issuer_signature)

  return hasher.digest()


def cert_signature(cert: nstp_proto.Certificate, signing_key):
  state = nacl.bindings.crypto_sign_ed25519ph_state()
  for subject in cert.subjects:
    nacl.bindings.crypto_sign_ed25519ph_update(state, subject.encode("UTF-8"))
  nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_from.to_bytes(8, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, cert.valid_length.to_bytes(4, 'big'))
  for usage in cert.usages:
    if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (3).to_bytes(1, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, cert.encryption_public_key)
  nacl.bindings.crypto_sign_ed25519ph_update(state, cert.signing_public_key)
  if cert.HasField("issuer"):
    nacl.bindings.crypto_sign_ed25519ph_update(state, cert.issuer.value)
    if cert.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif cert.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
  return nacl.bindings.crypto_sign_ed25519ph_final_create(state, signing_key)


def response_signature(resp: nstp_proto.CertificateStatusResponse, signing_key):
  state = nacl.bindings.crypto_sign_ed25519ph_state()
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.certificate.value)
  if resp.certificate.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
  elif resp.certificate.algorithm is nstp_proto.HashAlgorithm.SHA256:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
  elif resp.certificate.algorithm is nstp_proto.HashAlgorithm.SHA512:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
  if resp.status is nstp_proto.CertificateStatus.UNKNOWN:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
  elif resp.status is nstp_proto.CertificateStatus.VALID:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
  elif resp.status is nstp_proto.CertificateStatus.REVOKED:
    nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.valid_from.to_bytes(8, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.valid_length.to_bytes(4, 'big'))

  for subject in resp.status_certificate.subjects:
    nacl.bindings.crypto_sign_ed25519ph_update(state, subject.encode("UTF-8"))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.valid_from.to_bytes(8, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.valid_length.to_bytes(4, 'big'))
  for usage in resp.status_certificate.usages:
    if usage is nstp_proto.CertificateUsage.CERTIFICATE_SIGNING:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.CLIENT_AUTHENTICATION:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.SERVER_AUTHENTICATION:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
    elif usage is nstp_proto.CertificateUsage.STATUS_SIGNING:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (3).to_bytes(1, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.encryption_public_key)
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.signing_public_key)
  if resp.status_certificate.HasField("issuer"):
    nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.issuer.value)
    if resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.IDENTITY:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (0).to_bytes(1, 'big'))
    elif resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.SHA256:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (1).to_bytes(1, 'big'))
    elif resp.status_certificate.issuer.algorithm is nstp_proto.HashAlgorithm.SHA512:
      nacl.bindings.crypto_sign_ed25519ph_update(state, (2).to_bytes(1, 'big'))
  nacl.bindings.crypto_sign_ed25519ph_update(state, resp.status_certificate.issuer_signature)

  return nacl.bindings.crypto_sign_ed25519ph_final_create(state, signing_key)

##################################################
############ Write to the pinned store
##################################################
hello = open("~/mod_pinned_certs.db", "wb+")
pinned_c_store = nstp_proto.PinnedCertificateStore()
pinned_c1 = nstp_proto.PinnedCertificate()
pinned_c1.subject = status_cert.subjects[0]
pinned_c1.certificate.value = create_hash(status_cert, hashlib.sha512())
pinned_c1.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
pinned_c2 = nstp_proto.PinnedCertificate()
pinned_c2.subject = client_cert.subjects[0]
pinned_c2.certificate.value = create_hash(client_cert, hashlib.sha512())
pinned_c2.certificate.algorithm = nstp_proto.HashAlgorithm.SHA512
pinned_c_store.pinned_certificates.extend([pinned_c1, pinned_c2])

hello.write(pinned_c_store.SerializeToString())
hello.close()


print("writing to file")
print(pinned_c_store)


main()
time.sleep(1)
